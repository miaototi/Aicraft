"use strict";(globalThis.webpackChunkaicraft_website=globalThis.webpackChunkaicraft_website||[]).push([[808],{4782(e,n,r){r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>t});const a=JSON.parse('{"id":"api/memory","title":"Memory","description":"#include","source":"@site/docs/api/memory.md","sourceDirName":"api","slug":"/api/memory","permalink":"/docs/api/memory","draft":false,"unlisted":false,"editUrl":"https://github.com/TobiasTesauri/Aicraft/tree/main/docs/api/memory.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"Memory"},"sidebar":"docsSidebar","previous":{"title":"Optimizer","permalink":"/docs/api/optimizer"},"next":{"title":"SIMD Kernels","permalink":"/docs/api/simd"}}');var l=r(4848),o=r(8453);const i={sidebar_position:7,title:"Memory"},c="Memory API",s={},t=[{value:"Aligned Allocation",id:"aligned-allocation",level:2},{value:"Arena Allocator",id:"arena-allocator",level:2},{value:"Structure",id:"structure",level:3},{value:"Functions",id:"functions",level:3},{value:"Checkpoint / Restore",id:"checkpoint--restore",level:3},{value:"Properties",id:"properties",level:3},{value:"Pool Allocator",id:"pool-allocator",level:2},{value:"Global Arena",id:"global-arena",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"memory-api",children:"Memory API"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.code,{children:"#include <aicraft/memory.h>"})}),"\n",(0,l.jsx)(n.h2,{id:"aligned-allocation",children:"Aligned Allocation"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-c",children:"void* ac_aligned_alloc(size_t size, size_t alignment);\r\nvoid  ac_aligned_free(void* ptr);\n"})}),"\n",(0,l.jsx)(n.p,{children:"Cross-platform SIMD-aligned allocation:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Windows"}),": ",(0,l.jsx)(n.code,{children:"_aligned_malloc"})," / ",(0,l.jsx)(n.code,{children:"_aligned_free"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"C11"}),": ",(0,l.jsx)(n.code,{children:"aligned_alloc"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"POSIX"}),": ",(0,l.jsx)(n.code,{children:"posix_memalign"})]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Default alignment: 64 bytes (cache-line and AVX-512 aligned)."}),"\n",(0,l.jsx)(n.h2,{id:"arena-allocator",children:"Arena Allocator"}),"\n",(0,l.jsx)(n.p,{children:"The arena allocator provides fast bump-pointer allocation with bulk deallocation."}),"\n",(0,l.jsx)(n.h3,{id:"structure",children:"Structure"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-c",children:"typedef struct ac_arena_block {\r\n    uint8_t* data;\r\n    size_t size, used;\r\n    struct ac_arena_block* next;\r\n} ac_arena_block;\r\n\r\ntypedef struct {\r\n    ac_arena_block* head;\r\n    ac_arena_block* current;\r\n} ac_arena;\n"})}),"\n",(0,l.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-c",children:"void  ac_arena_init(ac_arena* a, size_t block_size);    // Default: 64 MB\r\nvoid* ac_arena_alloc(ac_arena* a, size_t size);          // Bump-pointer alloc\r\nvoid  ac_arena_reset(ac_arena* a);                       // Reset all blocks\r\nvoid  ac_arena_destroy(ac_arena* a);                     // Free all memory\n"})}),"\n",(0,l.jsx)(n.h3,{id:"checkpoint--restore",children:"Checkpoint / Restore"}),"\n",(0,l.jsx)(n.p,{children:"The key optimization for training loops:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-c",children:"ac_arena_checkpoint cp;\r\n\r\n// Save current position\r\nac_arena_save(&g_tensor_arena, &cp);\r\n\r\n// ... allocate intermediates (forward pass, backward, etc.) ...\r\n\r\n// Restore \u2014 all allocations since save are instantly freed\r\nac_arena_restore(&g_tensor_arena, &cp);\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"Memory layout during training:\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 Model params \u2502 Intermediates (freed)     \u2502\r\n\u2502 (survive)    \u2502\u25c4\u2500\u2500 checkpoint here        \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                \u2191 save()          restore() \u2191\n"})}),"\n",(0,l.jsx)(n.h3,{id:"properties",children:"Properties"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"O(1) allocation"}),": Bump pointer, no free-list traversal"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"O(1) bulk free"}),": Reset pointer position"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"SIMD-aligned"}),": All allocations are 64-byte aligned"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Auto-growing"}),": New 64 MB blocks allocated as needed"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"No fragmentation"}),": Linear allocation pattern"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"pool-allocator",children:"Pool Allocator"}),"\n",(0,l.jsx)(n.p,{children:"Fixed-size free-list allocator for uniform objects."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-c",children:"typedef struct {\r\n    void* buffer;\r\n    size_t obj_size, capacity;\r\n    ac_pool_free_node* free_list;\r\n} ac_pool;\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-c",children:"ac_pool pool;\r\nac_pool_init(&pool, sizeof(my_struct), 1024);  // 1024 objects\r\n\r\nvoid* obj = ac_pool_alloc(&pool);   // O(1) from free list\r\nac_pool_free(&pool, obj);           // O(1) return to free list\r\n\r\nac_pool_destroy(&pool);\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Includes bounds checking: ",(0,l.jsx)(n.code,{children:"ac_pool_free"})," validates that the pointer belongs to the pool's buffer range."]}),"\n",(0,l.jsx)(n.h2,{id:"global-arena",children:"Global Arena"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-c",children:"extern ac_arena g_tensor_arena;  // Used by all tensor allocations\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Initialized by ",(0,l.jsx)(n.code,{children:"ac_init()"}),", destroyed by ",(0,l.jsx)(n.code,{children:"ac_cleanup()"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453(e,n,r){r.d(n,{R:()=>i,x:()=>c});var a=r(6540);const l={},o=a.createContext(l);function i(e){const n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);
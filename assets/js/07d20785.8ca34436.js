"use strict";(globalThis.webpackChunkaicraft_website=globalThis.webpackChunkaicraft_website||[]).push([[844],{863(s,e,n){n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>t,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"api/loss","title":"Loss Functions","description":"#include","source":"@site/docs/api/loss.md","sourceDirName":"api","slug":"/api/loss","permalink":"/docs/api/loss","draft":false,"unlisted":false,"editUrl":"https://github.com/TobiasTesauri/Aicraft/tree/main/docs/api/loss.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Loss Functions"},"sidebar":"docsSidebar","previous":{"title":"Layers","permalink":"/docs/api/layers"},"next":{"title":"Optimizer","permalink":"/docs/api/optimizer"}}');var o=n(4848),a=n(8453);const t={sidebar_position:5,title:"Loss Functions"},i="Loss Functions API",c={},l=[{value:"Cross-Entropy Loss",id:"cross-entropy-loss",level:2},{value:"Mean Squared Error",id:"mean-squared-error",level:2},{value:"Binary Cross-Entropy",id:"binary-cross-entropy",level:2},{value:"Usage in Training",id:"usage-in-training",level:2}];function d(s){const e={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...s.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"loss-functions-api",children:"Loss Functions API"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"#include <aicraft/loss.h>"})}),"\n",(0,o.jsx)(e.h2,{id:"cross-entropy-loss",children:"Cross-Entropy Loss"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-c",children:"ac_tensor* loss = ac_cross_entropy_loss(logits, labels);\r\n// logits: [batch, num_classes] \u2014 raw scores (pre-softmax)\r\n// labels: [batch, num_classes] \u2014 one-hot encoded targets\r\n// Returns: scalar tensor (mean loss over batch)\n"})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Implementation"}),": Fused softmax + cross-entropy. The gradient is computed as:"]}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"\u2207_logits = softmax(logits) - labels"})}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["This fused formulation is numerically stable and avoids computing ",(0,o.jsx)(e.code,{children:"log(softmax)"})," separately."]}),"\n",(0,o.jsx)(e.h2,{id:"mean-squared-error",children:"Mean Squared Error"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-c",children:"ac_tensor* loss = ac_mse_loss(predictions, targets);\r\n// predictions, targets: same shape\r\n// Returns: scalar tensor = mean((pred - target)^2)\n"})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Gradient"}),":"]}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"\u2207_pred = (2/N) * (pred - target)"})}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"SIMD-vectorized using FMA operations."}),"\n",(0,o.jsx)(e.h2,{id:"binary-cross-entropy",children:"Binary Cross-Entropy"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-c",children:"ac_tensor* loss = ac_bce_loss(sigmoid_output, labels);\r\n// sigmoid_output: [batch, 1] \u2014 values in (0, 1)\r\n// labels: [batch, 1] \u2014 binary labels (0 or 1)\r\n// Returns: scalar tensor\n"})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Gradient"}),":"]}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.code,{children:"\u2207 = (\u0177 - y) / (\u0177 * (1 - \u0177))"})}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Clamped to prevent division by zero at the boundaries."}),"\n",(0,o.jsx)(e.h2,{id:"usage-in-training",children:"Usage in Training"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-c",children:"// Classification\r\nac_tensor* logits = ac_dense_forward(&fc, features);\r\nac_tensor* loss = ac_cross_entropy_loss(logits, one_hot_labels);\r\nac_backward(loss);\r\n\r\n// Regression\r\nac_tensor* pred = ac_dense_forward(&fc, features);\r\nac_tensor* loss = ac_mse_loss(pred, targets);\r\nac_backward(loss);\r\n\r\n// Binary classification\r\nac_tensor* raw = ac_dense_forward(&fc, features);\r\nac_tensor* prob = ac_tensor_sigmoid(raw);\r\nac_tensor* loss = ac_bce_loss(prob, binary_labels);\r\nac_backward(loss);\n"})})]})}function p(s={}){const{wrapper:e}={...(0,a.R)(),...s.components};return e?(0,o.jsx)(e,{...s,children:(0,o.jsx)(d,{...s})}):d(s)}},8453(s,e,n){n.d(e,{R:()=>t,x:()=>i});var r=n(6540);const o={},a=r.createContext(o);function t(s){const e=r.useContext(a);return r.useMemo(function(){return"function"==typeof s?s(e):{...e,...s}},[e,s])}function i(s){let e;return e=s.disableParentContext?"function"==typeof s.components?s.components(o):s.components||o:t(s.components),r.createElement(a.Provider,{value:e},s.children)}}}]);